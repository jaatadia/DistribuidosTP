/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#define _GNU_SOURCE
#include "idServer.h"
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h> //para lseek 
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h> //para lseek

#define TAMLONG 10
#define TAMLINEA (TAMLONG+2+2+1+TAMLONG+1) //tamlinea=id(long)+ocupado(char)+p/e/s/m(char)+nroPuerta(int)
#define IDFILEPATH "./ids.txt"

long getId(char tipo, long nroPuerta){ //devuelve -1 si no existe el ID
	
    char buffer[TAMLINEA];
    int fd = open(IDFILEPATH,O_RDWR); //abro archivo
    if(fd==-1){
        printf("Error al abrir el archivo: %s",strerror(errno));
        return -2;
    }
    
    long id = 0;
    int encontrado = 0;
    int eof = 0;
    
    //recorrer secuencialmente hasta leer "...-tipo-nro" o eof
    int leido;
    while (!encontrado && !eof) {
        leido = read(fd,&buffer,TAMLINEA);		
        if (leido < TAMLINEA) {
            eof = 1;
            lseek(fd,-leido,SEEK_CUR);
        } else if (buffer[11] == 'o' && buffer[13] == tipo) {
            //leo los numeros de puerta
            long nro;
            char str_nro[TAMLONG+1]; //pasar el nro de puerta del buffer a string
            int i;
            for (i=0;i<TAMLONG;i++){
                str_nro[i] = buffer[i+15];
            }
            str_nro[TAMLONG]='\0';
            nro=atol(str_nro);

            if (nro == nroPuerta) {
                //obtengo el id para devolver
                char str_id[TAMLONG+1]; //pasar el id del buffer a string
                for (i=0;i<TAMLONG;i++){
                    str_id[i] = buffer[i];
                }
                str_id[TAMLONG]='\0';
                id=atol(str_id);
                encontrado = 1;
            }
        }
    }
    if (!encontrado) {
        //error, no existe ese ID
        close(fd);
        return -1;
    }
    close(fd);
    return id;
}

long getNuevoId(char tipo,long nroPuerta){
    
    //si puertas ya habian pedido un id, devuelvo ese, sino (getID devuelve -1), busco uno nuevo
	if ((tipo == 'e') || (tipo == 's')) {
		long old_id = getId(tipo,nroPuerta);
                if(old_id == -2){
                    return -1;
		}else if (old_id != -1) {
                    return old_id;
		}
	}
    
    char buffer[TAMLINEA];
    int j; for(j=0;j<TAMLINEA;j++){buffer[j]='0';}

    int fd = open(IDFILEPATH,O_RDWR); //abro archivo
    if(fd==-1){
        printf("Error al abrir el archivo: %s",strerror(errno));
        return -1;
    }
    
    long id = 0;
    int ocupado = 1;
    int eof = 0;
    
    //recorrer secuencialmente hasta leer "id-l-..." o eof
    int leido;
    while (ocupado && !eof) {
        leido = read(fd,&buffer,TAMLINEA);
        if (leido < TAMLINEA) {
            eof = 1;
            int pos=lseek(fd,-leido,SEEK_CUR);
	    if((leido!=0)&&(pos-TAMLINEA>=0)){
		lseek(fd,-TAMLINEA,SEEK_CUR);
		read(fd,&buffer,TAMLINEA);
	    }
        } else if (buffer[11] == 'l'){
            ocupado = 0;
            lseek(fd,-TAMLINEA,SEEK_CUR); //posicionarme en la linea que decia 'l'
        }
    }

    int i;
    char str_id[TAMLONG+1]; //pasar el id del buffer a string
    for (i=0;i<TAMLONG;i++){
        str_id[i] = buffer[i];
    }
    str_id[TAMLONG]='\0';
    id=atol(str_id);

    if (ocupado) {
        id++;
    }
    
    printf("Entregado el id: %ld\n",id);
    sprintf(buffer,"%010ld-%c-%c-%010ld\n",id,'o',tipo,nroPuerta);
    write(fd,&buffer,TAMLINEA);
    close(fd);
    return id;
    
}

long devolverId(long id){
    printf("Devolvieron el id: %ld\n",id);
    char buffer[TAMLINEA];
    int fd = open(IDFILEPATH,O_RDWR); //abro archivo
    if(fd==-1){
        printf("Error al abrir el archivo: %s",strerror(errno));
        return -1;
    }

    //lseek al nro de id que me piden
    int res = lseek(fd,(id-1)*TAMLINEA,SEEK_SET);
    if (res == -1){
        close(fd);
        return -1;
    }
    //printf("res: %d \n",res);
    //chequeo si es el mismo
    read(fd,&buffer,TAMLINEA);
    //printf("leido: %s \n",buffer);

    char str_id[TAMLONG+1]; //pasar el id del buffer a string
    int i;
    for (i=0;i<TAMLONG;i++){
        str_id[i] = buffer[i];
    }
    str_id[TAMLONG]='\0';
    //printf("str id leido: %s \n",str_id);
    long id_leido=atol(str_id);
    //printf("id leido: %ld \n",id_leido);


    if (id_leido == id) {
        //cambio a 'l'
        lseek(fd,-TAMLINEA,SEEK_CUR); //posicionarme en la linea que leÃ­
        sprintf(buffer,"%010ld-%c-%c-%010ld\n",id,'l','l',(long)0);
        write(fd,&buffer,TAMLINEA);
        close(fd);
        return id;
    }
    //sino, return -1
    close(fd);
    return -1;
}

id_response *
getnuevoidpersona_1_svc(void *argp, struct svc_req *rqstp)
{
	static id_response  result;

        long id=getNuevoId('p',0);
        
        result.error=1; //TODO chequeo de errores!
        result.id_response_u.id=id;

	return &result;
}

id_response *
getnuevoidpuertaent_1_svc(long *argp, struct svc_req *rqstp)
{
	static id_response  result;
        long nroPuertaEnt = *argp;

        long id=getNuevoId('e',nroPuertaEnt);
        
        result.error=1;
        result.id_response_u.id=id;

	return &result;
}

id_response *
getnuevoidpuertasal_1_svc(long *argp, struct svc_req *rqstp)
{
	static id_response  result;
        long nroPuertaSal = *argp;

        long id=getNuevoId('s',nroPuertaSal);
        
        result.error=1;
        result.id_response_u.id=id;

	return &result;
}

id_response *
getnuevoidshmem_1_svc(void *argp, struct svc_req *rqstp)
{
	static id_response  result;

	long id=getNuevoId('m',0);
        
        result.error=1;
        result.id_response_u.id=id;

	return &result;
}

id_response *
getidpuertaent_1_svc(long *argp, struct svc_req *rqstp)
{
	static id_response  result;
        long nroPuertaEnt = *argp;

        long id = getId('e',nroPuertaEnt);
        
        if (id == -1) {
            result.error = 0;
            result.id_response_u.message = "No existe id para la puerta de entrada solicitada";
            return &result;
        }
        result.error=1;
        result.id_response_u.id=id;

	return &result;
}

id_response *
getidpuertasal_1_svc(long *argp, struct svc_req *rqstp)
{
	static id_response  result;
        long nroPuertaSal = *argp;

        long id = getId('s',nroPuertaSal);
        
        if (id == -1) {
            result.error = 0;
            result.id_response_u.message = "No existe id para la puerta de salida solicitada";
            return &result;
        }
        result.error=1;
        result.id_response_u.id=id;

	return &result;
}

id_response *
devolverid_1_svc(long *argp, struct svc_req *rqstp)
{
	static id_response  result;
        long id = *argp;

        long res = devolverId(id);
        if (res == -1) {
            result.error = 0;
            result.id_response_u.message = "No se pudo devolver el id";
            return &result;
        }
        result.error=1;
        result.id_response_u.id=res;

	return &result;
}
